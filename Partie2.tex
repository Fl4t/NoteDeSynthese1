\chapter{Script de comparaison de base de donnée}

N'ayant pas de notion de programmation orienté objet\, \footnote{Ce qui sera
enseigner en deuxieme année.} je n'ai pas pu rejoindre les developeur de
l'entreprise dans l'application qu'ils étaient occupés d'éffectuer, cela dit on
m'a confier une tache annexe qui est la comparaison des bases de données.

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{images/bdd.png}
\end{center}
\caption{Un schéma de base de donnée simple.}
\end{figure}

Le besoin premier de ce script est de consulter les différences de structure qui
existe entre une base de référence est une base à mettre à jour. Dans le cas de
l'entreprise, il permettrait un suivi des mises à jour des applications fournis
au client, et pour moi, m'initier à la programmation orienté objet\,
\footnote{La programmation orientée objet est un paradigme de programmation qui
consiste à utiliser des objets ; un objet représente un concept, une idée ou
toute entité du monde physique, comme une voiture, une personne ou encore une
page d'un livre.} des le premier stage.

\section{Le départ}

À l'aide d'un cours sur internet, j'ai commencé à créer ma première classe.
Cette classe après instanciation représenterait l'objet \og{} base de donnée
\fg{} sous forme de tableau.

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{images/objet.png}
\end{center}
\caption{Un plan à partir duquel on crée des objets.}
\end{figure}

Passer de la programmation fonctionnelle\, \footnote{La programmation
fonctionnelle est un paradigme de programmation qui repose sur l'utilisation
majoritaire des fonctions et procédures.} à l'objet fut vraiment difficile. Me
rendant compte que je bloquai énormément, je fis des recherches sur internet
pour trouver un programme équivalent sur lequel je me suis appuyer pour
commencer. M.\bsc{Dubourg} m'a mis sur la voie en me disant d'utiliser des classes
est des méthodes toute prête de l'entreprise ce qui m'ôtas une grosse épine du
pied car je n'avais aucune idée de comment je devais faire pour transcrire une
structure de base de donnée en objet.

Pour utiliser les sources de la société, j'ai du mettre en place un répertoire
de travail et récupérer les sources via leur ancien gestionnaire de version de
code source.  Ceci étant fait il s'agissait maintenant de réussir à faire
fonctionner le site web principal en local sur ma machine. Mon logiciel MAMP\,
\footnote{\emph{Macintosh Apache MySQL Php} est une combinaison de logiciel.}
m'affichant plein d'erreurs, j'ai décidé d'installer manuellement chacun des
logiciels présents dans celui-ci.  Même après cette manipulation le problème
n'avais pas disparu, mon tuteur de stage m'est venu en aide après de longues
heures à chercher en vain. Le problème ce trouvai au niveau de la configuration
de PHP\, \footnote{\emph{Hypertext Preprocessor} est un langage de scripts
libre principalement utilisé pour produire des pages Web dynamiques.} qui
affichai tout les avertissements de manière trop stricte, ce qui refusai tout
lancement de la page principale et aussi le fait que je devais vider le cache
de mon navigateur. De nombreuses heures de recherche juste à cause d'un cache
internet pas vidé fut extrêmement frustrant...

\section{Comparaison des tables}

%%% arrivé ici %%%

Il a fallut dans un premier temps que je recherche comment extraire le nom
d'une base de donnée ainsi que le nom de ses tables. La réponse à cette
question est dans la documentation de MySQL. Une base de donnée est fournit à
l'installation et elle s'apelle information schéma. En résumé, c'est une base
de donnée qui contient les autres bases de donnée.

Ensuite, j'ai transformer le programme procédural sur plusieurs semaines en
objet, le fait de passer par cette étape intermédiaire m'as permis d'abord de
résoudre le problème algorithmique, puis après me consacrer sur la façon de
l'écrire.

La requête récuperant les données utiles, il a fallut concevoir un algorithme
capable de comparer les deux tableaux d'objets par rapport à leurs nom :
\begin{itemize}
    \item Si la base de donnée de référence à une table qui n'est
        pas dans la base de donnée à mettre à jour, on l'ajoute ;
    \item Si la base de donnée de mise à jour contient une table qui n'est pas
        dans la base de donnée de référence, on l'enlève ;
    \item Si les tables comparées sont toutes les deux dans les base de donnée,
    on compare l'interieur des tables.
\end{itemize}

J'ai du revoir mon algorithme plusieurs fois car la fonction de comparaison de
chaine de caractère \emph{strnatcmp} comparait les mots comme un humain le
ferait, alors que mySQL trie les tables de manière binaire c'est a dire les
codes Ascii des caractères ce qui fesait que la première fonction donner des
resultats érronées comme le montre le tableau ci-dessous.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Tri de chaînes standard} & \textbf{Tri de chaînes ordre naturel} \\
\hline
[0] = img1.png & [0] = img1.png \\
\hline
[1] = img10.png & [1] = img2.png \\
\hline
[2] = img12.png & [2] = img10.png \\
\hline
[3] = img2.png & [3] = img12.png \\
\hline
\end{tabular}
\end{center}

\section{Comparaison des champs}

Maintenant que je me retrouvai dans des tables ayant les mêmes noms, il fallait
que je compare le contenu, lui aussi en comparant le nom des champs, il m'as
pas fallut longtemps pour comprendre que l'algorithme était exactement le même,
le plus dur étant de savoir comment j'allais faire pour me répeter le minimum
possible ce qui a bloqué énormement mon avancement pour pas grand chose.
M.\bsc{Dubourg} constatant que je n'avançais plus ma conseiller de faire comme
je l'avais appris plutôt que d'éssayer de faire de la POO tout de suite. Une
fois le script fonctionnel mais très mal optimisé et peu lisible, mon tuteur
m'a guidé via des annotations est des explications poussées sur la marche qui
semblai la meilleur. De fil en aiguille le code source est passé d'environ
trois-cent cinquante lignes à cent cinquante.

Ensuite légèrement différent, je devais comparer le contenu des champs des
tables lorsque les champs parcouru avait le même nom, je compare tout
simplement le contenu des champ pour connaitre l'issue finale, à savoir que je
ne pouvais pas décider si les tables était similaire sans avoir balayer tout
les champs et toutes les caractèristique de ceux-ci.

\section{Affichage du résultat}

Après tout ceci fini est optimisé, j'implémente une nouvelle fonctionnalité qui
serai d'afficher un texte lisible qui énonce les differences des deux bases
donnée. En fonction des résultats obtenu, je génère des balises html et du
texte pour que cela soit comprehensible à l'utilisateur. Ceci étant fait assez
rapidement je suis passé à la génération des requetes SQL permettant de mettre
a jour la base de donnée comparé à la référence. C'est à ce stade que j'ai
constaté que je ne pourrais pas prendre en compte les clés étrangère dans mon
code à moin de revoir totalement tout le script.  M.\bsc{Dubourg} ma rassurer sur le
fait que l'entreprise n'utilisai pas le type de base de donnée MySLAM et que
donc aucune de leurs table comportait de clé étrangère, cependant les clés
primaire concaténées reste problèmatique car pas imaginer pendant la
conception. Nous avons décider que la création de ce genre de cas ce fera à la
main pour pas repartir de zéro.

Après avoir analyser mes methodes de génération de phrase lisible et de
requetes SQL, M.\bsc{Dubourg} ma présenter un outils nommée "Smarty" qui permet de
dissocier la partie traitement de la partie affichage car il est vrai que mes
méthodes était vraiment très sale. Pour résumer, j'écrivais des chaines de
caractère dans une seule variable en écrivant les noms des tables ou des
champs, en concatenant le tout avec des balises html de saut de ligne un peu
nimporte où. J'ai du parcourir la documentation de Smarty pour comprendre son
fonctionnement, il s'avère que la synthaxe est très particulière mais très
éfficace. J'ai terminer par faire de l'agencement sur ma page pour que chaque
ligne lisible par un néophyte soit en face de la ligne en SQL dans un tableau a
deux colonnes tout ceci avec l'aide de smarty.

\clearpage
